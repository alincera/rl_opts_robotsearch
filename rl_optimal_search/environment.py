# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/environment.ipynb (unless otherwise specified).

__all__ = ['get_distance', 'isBetween', 'isBetween_ab_Vec', 'isBetween_c_Vec', 'target_env']

# Cell
import torch
import numpy as np
from math import pi, cos, sin

# Cell
from scipy.optimize import curve_fit
from scipy.special import factorial
from scipy.stats import poisson


def get_distance(x):
    M = np.reshape(np.repeat(x[ :, :], x.shape[0], axis = 0), (x.shape[0], x.shape[0], 2))
    Mtrans = M.transpose(1,0,2)
    distance = np.sqrt(np.square(M[:,:, 0]-Mtrans[:,:, 0])
                     + np.square(M[:,:, 1]-Mtrans[:,:, 1]))
    return distance

def isBetween(a, b, c, epsilon = 0):
    crossproduct = (c[1] - a[1]) * (b[0] - a[0]) - (c[0] - a[0]) * (b[1] - a[1])

    # compare versus epsilon for floating point values, or != 0 if using integers
    if abs(crossproduct) > epsilon:
        return False

    dotproduct = (c[0] - a[0]) * (b[0] - a[0]) + (c[1] - a[1])*(b[1] - a[1])
    if dotproduct < 0:
        return False

    squaredlengthba = (b[0] - a[0])*(b[0] - a[0]) + (b[1] - a[1])*(b[1] - a[1])
    if dotproduct > squaredlengthba:
        return False

    return True

def isBetween_ab_Vec(a, b, c, epsilon = 0):
    mask = np.array([True]*a.shape[0])

    crossproduct = (c[1] - a[:,1]) * (b[:,0] - a[:,0]) - (c[0] - a[:, 0]) * (b[:, 1] - a[:, 1])
    mask[np.argwhere(abs(crossproduct) > epsilon)] = False

    dotproduct = (c[0] - a[:, 0]) * (b[:, 0] - a[:, 0]) + (c[1] - a[:, 1])*(b[:, 1] - a[:, 1])
    mask[np.argwhere(dotproduct < 0)] = False

    squaredlengthba = (b[:, 0] - a[:, 0])*(b[:, 0] - a[:, 0]) + (b[:, 1] - a[:, 1])*(b[:, 1] - a[:, 1])
    mask[np.argwhere(dotproduct > squaredlengthba)] = False

    return mask

def isBetween_c_Vec(a, b, c, epsilon = 0):
    mask = np.array([True]*c.shape[0])

    crossproduct = (c[:,1] - a[1]) * (b[0] - a[0]) - (c[:,0] - a[0]) * (b[1] - a[1])
    mask[np.argwhere(abs(crossproduct) > epsilon)] = False

    dotproduct = (c[:, 0] - a[0]) * (b[0] - a[0]) + (c[:, 1] - a[1])*(b[1] - a[1])
    mask[np.argwhere(dotproduct < 0)] = False

    squaredlengthba = (b[0] - a[0])*(b[0] - a[0]) + (b[1] - a[1])*(b[1] - a[1])
    mask[np.argwhere(dotproduct > squaredlengthba)] = False

    return mask

# Cell
class target_env():
    def __init__(self,
                 Nt = 1000,
                 L = 200,
                 at = 1,
                 ls = 2,
                 agent_step = 1,
                 boundary_condition = 'periodic'):

        self.Nt = Nt
        self.L = L
        self.at = at
        self.ls = ls
        self.boundary_condition = boundary_condition

        self.init_env()

        self.agent_step = agent_step

    def init_env(self):
        self.target_positions = torch.rand(self.Nt, 2)*self.L
        self.agent_pos = torch.rand(2)*self.L
        self.previous_pos = self.agent_pos.clone()


    def step(self, direction):

        # Save previous position to check if crossing happened
        self.previous_pos = self.agent_pos.clone()

        self.agent_pos[0] = self.agent_pos[0] + self.agent_step*cos(direction)
        self.agent_pos[1] = self.agent_pos[1] + self.agent_step*sin(direction)

        self.check_bc()

    def check_encounter(self):
        encounters = isBetween_c_Vec(self.agent_pos, self.previous_pos, self.target_positions, epsilon = self.at)

        if sum(encounters) > 0:
            distance_previous_pos = torch.sqrt((self.agent_pos[0]-self.target_positions[:, 0])**2 + (self.agent_pos[1]-self.target_positions[:, 1])**2)

            # checking which encountered point is closer to previous position
            min_distance_masked = torch.argmin(distance_previous_pos[encounters])
            first_encounter = torch.arange(self.Nt)[encounters][min_distance_masked]

            # If there was encounter, update the position to (pos target + ls)
            self.agent_pos[0] = self.target_positions[first_encounter, 0] + self.ls*np.cos(torch.rand(1)*2*pi)
            self.agent_pos[1] = self.target_positions[first_encounter, 1] + self.ls*np.sin(torch.rand(1)*2*pi)

            self.check_bc()

            return 1

        else: return 0

    def check_bc(self):
        if self.boundary_condition == 'reflectant':
            while torch.max(self.agent_pos) > self.L or torch.min(self.agent_pos)< 0:
                out_high = self.agent_pos > self.L
                out_low = self.agent_pos < 0
                self.agent_pos[out_high] = self.agent_pos[out_high] - 2*(self.agent_pos[out_high] - self.L)
                self.agent_pos[out_low] = - self.agent_pos[out_low]


        elif self.boundary_condition == 'periodic':
            while torch.max(self.agent_pos) > self.L or torch.min(self.agent_pos)< 0:
                out_high = self.agent_pos > self.L
                out_low = self.agent_pos < 0
                self.agent_pos[out_high] = self.agent_pos[out_high] - self.L
                self.agent_pos[out_low] = self.L + self.agent_pos[out_low]
