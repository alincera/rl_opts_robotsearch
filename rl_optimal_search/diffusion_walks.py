# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/diffusion_walks.ipynb (unless otherwise specified).

__all__ = ['lw_step', 'lw_trajs', 'multiexp_dist', 'discrete_multiexp_step']

# Cell
import numpy as np
from tqdm.auto import tqdm, trange

# Cell
def lw_step(alpha, num_part = 1):
    return (1 - np.random.rand(num_part))**(-1/alpha)

# Cell
def lw_trajs(N = 1, T = 100, alpha = 1, L = None, BC = 'reflectant'):

    pos = np.zeros((N, T, 2))

    if L is None:

        angles = np.random.uniform(low = 0, high = 2*np.pi, size = (N, T))
        steps = (1 - np.random.rand(N, T))**(-1/alpha)
        pos[:, :, 0], pos[:, :, 1] = [steps*np.cos(angles), steps*np.sin(angles)]

        return np.cumsum(pos, axis = 1)

    else:

        pos = np.zeros((N, T, 2))
        pos[:, 0, :] = np.random.rand(N, 2)*L

        for t in tqdm(range(1, T)):

            angles = np.random.uniform(low = 0, high = 2*np.pi, size = N)
            steps = (1 - np.random.rand(N))**(-1/alpha)
            pos[:, t, 0] = pos[:, t-1, 0] + steps*np.cos(angles)
            pos[:, t, 1] = pos[:, t-1, 1] + steps*np.sin(angles)


        if BC == 'reflectant':
            while np.max(pos[:, t, :])>L or np.min(pos[: ,t, :])< 0:
                pos[pos > L] = pos[pos > L] - 2*(pos[pos > L] - L)
                pos[pos < 0] = - pos[pos < 0]


        elif BC == 'periodic':
            while np.max(pos[:, t, :])>L or np.min(pos[: ,t, :])< 0:
                pos[pos > L] = pos[pos > L] - L
                pos[pos < 0] = L + pos[pos < 0]



        return pos

# Cell
def multiexp_dist(x, ws, ds):
    val = 0
    for wi, di in zip(ws, ds):
        # discrete normalization from 1 to inf
        norm = (wi/di)/(np.exp(1/di)-1)
        val += (1/norm)* (wi/di) * np.exp(- x / di)
    return val/len(ws)

# Cell
def discrete_multiexp_step(ws, ds, L_max=1000, num_samples = 1):
    probs = multiexp_dist(np.arange(1, L_max), ws, ds)
    probs /= np.sum(probs)
    return np.random.choice(np.arange(1, L_max), p = probs, size = num_samples)