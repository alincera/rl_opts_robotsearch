# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/diffusion_walks.ipynb.

# %% auto 0
__all__ = ['x0', 'Ls', 'n_jobs', 'reps', 'betas', 'names', 'Ts', 'Ns', 'path', 'lw_step', 'lw_trajs', 'multiexp_dist',
           'discrete_multiexp_step', 'constant_velocity_generator', 'mfpt_rw', 'mfpt_informed_rw', 'rw_generator',
           'exp_generator', 'exp_time_generator', 'Biexp', 'biexp_time_generator', 'powerlaw_generator',
           'constant_velocity_generator_2D', 'mfpt_rw_2D', 'mfpt_informed_rw_2D']

# %% ../nbs/diffusion_walks.ipynb 3
import numpy as np
from tqdm.notebook import tqdm, trange
from tqdm import tqdm as tqdm_term
from joblib import Parallel, delayed
from .environment import isBetween_ab_Vec, target_search_onhit
from typing import Callable
from .utils import add_colorbar


# %% ../nbs/diffusion_walks.ipynb 7
def lw_step(beta, num_samples = 1):
    return (1 - np.random.rand(num_samples))**(-1/(beta))

# %% ../nbs/diffusion_walks.ipynb 11
def lw_trajs(N = 1, T = 100, alpha = 1, L = None, BC = 'reflectant'):
    
    pos = np.zeros((N, T, 2))
    
    if L is None:
        
        angles = np.random.uniform(low = 0, high = 2*np.pi, size = (N, T))
        steps = (1 - np.random.rand(N, T))**(-1/alpha)
        pos[:, :, 0], pos[:, :, 1] = [steps*np.cos(angles), steps*np.sin(angles)] 
   
        return np.cumsum(pos, axis = 1)

    else:
        
        pos = np.zeros((N, T, 2))
        pos[:, 0, :] = np.random.rand(N, 2)*L

        for t in tqdm(range(1, T)):

            angles = np.random.uniform(low = 0, high = 2*np.pi, size = N)
            steps = (1 - np.random.rand(N))**(-1/alpha)
            pos[:, t, 0] = pos[:, t-1, 0] + steps*np.cos(angles)
            pos[:, t, 1] = pos[:, t-1, 1] + steps*np.sin(angles)


        if BC == 'reflectant':
            while np.max(pos[:, t, :])>L or np.min(pos[: ,t, :])< 0: 
                pos[pos > L] = pos[pos > L] - 2*(pos[pos > L] - L)
                pos[pos < 0] = - pos[pos < 0]


        elif BC == 'periodic':
            while np.max(pos[:, t, :])>L or np.min(pos[: ,t, :])< 0: 
                pos[pos > L] = pos[pos > L] - L
                pos[pos < 0] = L + pos[pos < 0]     
        
            
        
        return pos

# %% ../nbs/diffusion_walks.ipynb 48
def multiexp_dist(x, ws, ds):
    val = 0
    for wi, di in zip(ws, ds):
        # discrete normalization from 1 to inf
        norm = (wi/di)/(np.exp(1/di)-1)
        val += (1/norm)* (wi/di) * np.exp(- x / di) 
    return val/len(ws)

# %% ../nbs/diffusion_walks.ipynb 57
def discrete_multiexp_step(ws, ds, L_max=1000, num_samples = 1):
    probs = multiexp_dist(np.arange(1, L_max), ws, ds)
    probs /= np.sum(probs)
    return np.random.choice(np.arange(1, L_max), p = probs, size = num_samples)

# %% ../nbs/diffusion_walks.ipynb 63
def constant_velocity_generator(N, # Number of trajectories
                                T, # Length of trajectories
                                time_sampler, # Sampler of time of constant velocity
                                velocity = 1, # Velocity
                                **sample_args # Optional arguments for the sampler
                               ):
    ''' Given a sampler for length of time steps, generates a trajectory considering a constant
    velocity in the sampled times. After each time step, we sample a new direction. '''
    
    trajs = np.zeros((N, T))
    
    for idxN in (range(N)):        
        
        times = time_sampler(num_samples = T+1, **sample_args).astype(int)
        
        max_t = np.argwhere(np.cumsum(times) > T+1).flatten()
        if len(max_t) > 0:
            max_t = max_t[0]
        else: max_t = T+1
        
        traj = np.array([0])
        cumsum = 0
        for time in times[:max_t+1]:
            segment = (2*np.random.randint(0, 2)-1)*np.arange(1, min(time+1, T+1))+traj[-1]
            
            traj = np.append(traj, segment)
            cumsum += len(segment)
            if cumsum > T:
                break

        trajs[idxN] = traj[:T]
        
    return trajs
    

# %% ../nbs/diffusion_walks.ipynb 68
from typing import Callable

def mfpt_rw(N:int, # Number of trajectories
            T:int, # Lengths of trajectories
            x0:float, # Starting point of walk
            Ls:list, # Boundary position
            traj_generator:Callable,  # Function generating the walk (must start in x0 = zero)
            max_loop = 5,  # Max number of while loop if some walks do not reach the boundary
            save = None,
            **args_generator # Arguments of the trajectory generator
           ): # MFPT vs. L
    ''' Calculates MFPT to boundaries at 0 and L starting in x0 '''
    
    trajs = traj_generator(N,T,**args_generator) + x0
    
    if save is not None:
        statistics_fpt = np.zeros((len(Ls), N))

    mfpt = []
    for idxL, L in tqdm_term(enumerate(Ls)):   
        first_passage = np.argmax((trajs < 0) | (trajs > L), axis = 1) 

        # Enlarging the time of those who did not hit the boundaries
        n_loop = 0
        non_passed = np.argwhere(first_passage == 0).flatten()
        last_non_passed = trajs[non_passed, -1]
        while len(non_passed) > 0 and n_loop < max_loop:
            
            trajs_upd = traj_generator(len(non_passed),T,**args_generator) + last_non_passed[..., np.newaxis]
            
            # Finding the FPT of the new trajectories
            first_upd = np.argmax((trajs_upd < 0) | (trajs_upd > L), axis = 1)            
            # Adding these to the main FPT array, considering that loop number
            first_passage[non_passed] = (first_upd + (n_loop+1)*T)*first_upd.astype(bool)

            # Checking the ones that still did not pass
            non_passed = np.argwhere(first_passage == 0).flatten()
            # updating the last element of the non passed trajectories
            upd_non_passed = np.argwhere(first_upd == 0).flatten()
            if len(non_passed) != len(upd_non_passed): print('ERROR')
            last_non_passed = trajs_upd[upd_non_passed, -1]
            # updating loop num
            n_loop += 1      
                                  
        if save is not None:
            statistics_fpt[idxL] = first_passage.copy()
                                

        # Calculating mean considering that some may not have passed              
        first_passage = first_passage[first_passage != 0].mean() 
        # Adding this MFPT for current L
        mfpt.append(first_passage)
        
        
        
    if save is not None:
        np.save(save+'.npy', mfpt)
        np.save(save+'_stats.npy', statistics_fpt)
        
    return mfpt

# %% ../nbs/diffusion_walks.ipynb 70
def mfpt_informed_rw(N:int, # Number of trajectories
            T:int, # Lengths of trajectories
            x0:float, # Starting point of walk
            Ls:list, # Boundary position
            traj_generator:Callable,  # Function generating the walk (must start in x0 = zero)
            max_loop = 5,  # Max number of while loop if some walks do not reach the boundary
            time_sampler = None,
            save = None,
            **args_generator # Optional                     
           ): # MFPT vs. L
    ''' Calculates MFPT to boundaries at 0 and L starting in x0 with a traj generator informed on the scales of the sysmte (x0 and L)'''
    
    if save is not None:
        statistics_fpt = np.zeros((len(Ls), N))

    mfpt = []
    for idxL, L in tqdm_term(enumerate(Ls)):  
        
        trajs = traj_generator(N, T, time_sampler = time_sampler, x0 = x0, L = L, informed = True)
        
        first_passage = np.argmax((trajs < 0) | (trajs > L), axis = 1) 

        # Enlarging the time of those who did not hit the boundaries
        n_loop = 0
        non_passed = np.argwhere(first_passage == 0).flatten()
        while len(non_passed) > 0 and n_loop < max_loop:
            last_non_passed = trajs[non_passed, -1]
            trajs_upd = traj_generator(len(non_passed),T, 
                                       time_sampler = time_sampler, x0 = x0, L = L, 
                                       informed = True) + last_non_passed[..., np.newaxis]

            # updating trajectories with new positions. This makes that last_non_passed is always correct
            trajs[non_passed, -1] = trajs_upd[:, -1]
            # Finding the FPT of the new trajectories
            first_upd = np.argmax((trajs_upd < 0) | (trajs_upd > L), axis = 1)            
            # Adding these to the main FPT array, considering that loop number
            first_passage[non_passed] = (first_upd + (n_loop+1)*T)*first_upd.astype(bool)

            # Checking the ones that still did not pass
            non_passed = np.argwhere(first_passage == 0).flatten()
            # updating loop num
            n_loop += 1      
                                  
        if save is not None:
            statistics_fpt[idxL] = first_passage.copy()
                                

        # Calculating mean considering that some may not have passed              
        first_passage = first_passage[first_passage != 0].mean() 
        # Adding this MFPT for current L
        mfpt.append(first_passage)
        
        
        
    if save is not None:
        np.save(save+'.npy', mfpt)
        np.save(save+'_stats.npy', statistics_fpt)
        
    return mfpt

# %% ../nbs/diffusion_walks.ipynb 72
def rw_generator(N, T):
    trajs = 2*np.random.randint(0, 2, size = (N,T))-1
    trajs[:,0] = 0
    trajs = np.cumsum(trajs, axis = 1)
    return trajs

# %% ../nbs/diffusion_walks.ipynb 76
def exp_generator(N, T):
    trajs = (2*np.random.randint(0, 2, size = (N,T))-1)*np.random.exponential(size = (N,T))
    trajs[:,0] = 0
    trajs = trajs.cumsum(axis = 1)
    return trajs

# %% ../nbs/diffusion_walks.ipynb 77
def exp_time_generator(num_samples):
    return np.random.exponential(size = num_samples)+1

# %% ../nbs/diffusion_walks.ipynb 82
from scipy.stats.sampling import NumericalInverseHermite

class Biexp():
    def __init__(self, informed = False, **args):
        
        if not informed:
            self.w1 = args['w1']
            self.d1 = args['d1']
            self.d2 = args['d2']
        else:
            self.w1 = 2*args['x0']/args['L']
            self.d1 = 3*args['L']
            self.d2 = args['x0']        
            
        
    def pdf(self, x):
        return (self.w1/self.d1)*np.exp(-x/self.d1) + ((1 - self.w1)/ self.d2)*np.exp(-x/self.d2)
    
    def cdf(self, x):
        return 1 + (self.w1-1)*np.exp(-x/self.d2) - self.w1*np.exp(-x/self.d1)
    
    def dpdf(self, x):
        return (self.w1/self.d1**2)*np.exp(-x/self.d1) + ((1 - self.w1)/ self.d2**2)*np.exp(-x/self.d2)
    
    def sample(self, num_rn):
        return NumericalInverseHermite(self, domain=(0, np.inf)).rvs(int(num_rn))

# %% ../nbs/diffusion_walks.ipynb 87
def biexp_time_generator(num_samples, **sample_kwargs):
    sampler = Biexp(**sample_kwargs)
    return sampler.sample(num_samples)+1

# %% ../nbs/diffusion_walks.ipynb 96
def powerlaw_generator(N, T, **args):    
    direction =  (2*np.random.randint(0, 2, size = (N,T))-1)    
    steps = lw_step(num_part=int(N*T), **args).reshape(N,T)
    trajs = direction*steps
    trajs[:,0] = 0
    trajs = trajs.cumsum(axis = 1)
    # Regularize trajectories
    for idxt, (traj, step) in enumerate(zip(trajs, steps)):
        times = np.cumsum(step)
        trajs[idxt] = regularize(traj, times, T)
    return trajs

# %% ../nbs/diffusion_walks.ipynb 110
x0, Ls = 3, np.arange(15, 100)
n_jobs = 10
reps = 5000

betas = np.linspace(0.1, 1.5, 10)

names = ['constant', 'exp', 'biexp_unif', 'biexp_inf', 'pw']
Ts = (np.array([1e4, 1e4, 1e4, 1e4, 1e3], dtype = int)).astype(int)
Ns = (np.array([1e3, 1e3, 1e3, 1e2, 1e4], dtype = int)).astype(int)
path = 'results_fpt/'



for idx in [3]:#range(len(names)):
    
    print(names[idx])
    
    if idx == 0: # Constant step length
        Parallel(n_jobs=n_jobs)(delayed(mfpt_rw)(N = Ns[idx], T = Ts[idx], 
                                                 x0 = x0, Ls = Ls, 
                                                 traj_generator = rw_generator,
                                                 save = path+names[idx]+f'_N_{np.log10(Ns[idx]).astype(int)}_L_{np.log10(Ts[idx]).astype(int)}_{rep}')
                                for rep in tqdm(range(reps)))



    if idx == 1: # Single exponential
        Parallel(n_jobs=n_jobs)(delayed(mfpt_rw)(N = Ns[idx], T = Ts[idx],
                                                 x0 = x0, Ls = Ls,
                                                 traj_generator = constant_velocity_generator,
                                                 time_sampler = exp_time_generator,
                                                 save = path+names[idx]+f'_N_{np.log10(Ns[idx]).astype(int)}_L_{np.log10(Ts[idx]).astype(int)}_{rep}')
                                for rep in tqdm(range(reps)))

    if idx == 2: # Uninformed biexponential
        Parallel(n_jobs=n_jobs)(delayed(mfpt_rw)(N = Ns[idx], T = Ts[idx],
                                                 x0 = x0, Ls = Ls,
                                                 traj_generator = constant_velocity_generator,
                                                 time_sampler = biexp_time_generator, w1 = 0.5, d1 = 1, d2 = 5,
                                                 save = path+names[idx]+f'_N_{np.log10(Ns[idx]).astype(int)}_L_{np.log10(Ts[idx]).astype(int)}_{rep}')
                                for rep in tqdm(range(reps)))


    
    if idx == 3: # Informed biexponential
        Parallel(n_jobs=n_jobs)(delayed(mfpt_informed_rw)(N = Ns[idx], T = Ts[idx],
                                                          x0 = x0, Ls = Ls, 
                                                          traj_generator = constant_velocity_generator,
                                                          time_sampler = biexp_time_generator,
                                                          save = path+names[idx]+f'_N_{np.log10(Ns[idx]).astype(int)}_L_{np.log10(Ts[idx]).astype(int)}_{rep+500}')
                                for rep in tqdm(range(reps)))

    if idx == 4: # Power law multiple betas
        for idxb, beta in enumerate(betas):
            print(round(idxb/len(betas),2))
            Parallel(n_jobs=n_jobs)(delayed(mfpt_rw)(N = Ns[idx], T = Ts[idx],
                                                     x0 = x0, Ls = Ls, 
                                                     traj_generator = constant_velocity_generator,
                                                     time_sampler = lw_step, beta = beta,
                                                     save = path+names[idx]+f'_beta{round(beta,3)}_N_{np.log10(Ns[idx]).astype(int)}_L_{np.log10(Ts[idx]).astype(int)}_{rep}')
                                    for rep in tqdm(range(reps)))

# %% ../nbs/diffusion_walks.ipynb 121
def constant_velocity_generator_2D(N, # Number of trajectories
                                   T, # Length of trajectories
                                   time_sampler, # Sampler of time of constant velocity
                                   velocity = 1, # Velocity
                                   **sample_args # Optional arguments for the sampler
                               ):
    ''' Given a sampler for length of time steps, generates a 2D trajectory considering a constant
    velocity in the sampled times. After each time step, we sample a new direction. '''
    
    trajs_x = np.zeros((N, T))
    trajs_y = np.zeros((N, T))
    
    for idxN in (range(N)):        
        
        times = time_sampler(num_samples = T+1, **sample_args).astype(int)
        
        # If we have too many times (e.g. because we sampled big times),
        # we cut the times vector with max_t
        max_t = np.argwhere(np.cumsum(times) > T+1).flatten()
        if len(max_t) > 0:
            max_t = max_t[0]
        else: max_t = T+1
        
        traj_x = np.array([0])
        traj_y = np.array([0])
        cumsum = 0
        for time in times[:max_t+1]:
            angle = np.random.rand()*2*np.pi
            
            segment_x = np.cos(angle)*np.arange(1, min(time+1, T+1))+traj_x[-1]
            segment_y = np.sin(angle)*np.arange(1, min(time+1, T+1))+traj_y[-1]
            
            traj_x = np.append(traj_x, segment_x)
            traj_y = np.append(traj_y, segment_y)
            
            cumsum += len(segment_x)
            if cumsum > T:
                break

        trajs_x[idxN] = traj_x[:T]
        trajs_y[idxN] = traj_y[:T]        
    
    return trajs_x, trajs_y
    

# %% ../nbs/diffusion_walks.ipynb 126
from typing import Callable

def mfpt_rw_2D(N:int, # Number of trajectories
               T:int, # Lengths of trajectories
               x0:list, # Starting point of walk (in 2d)
               Ls:list, # Boundary position
               traj_generator:Callable,  # Function generating the walk (must start in x0 = zero)
               max_loop = 5,  # Max number of while loop if some walks do not reach the boundary
               **args_generator # Arguments of the trajectory generator
           ): # MFPT vs. L
    ''' Calculates MFPT to boundaries at 0 and L starting in x0 in 2D'''



    # Debug
    # N = 5; T = 50; x0 = [3,3]; Ls = [99]; max_loop = 40

    trajs_x, trajs_y = traj_generator(N, T, **args_generator)
    
    trajs_x += x0[0]
    trajs_y += x0[1]

    mfpt = []
    for L in tqdm_term(Ls):   

        first_passage_x = np.argmax((trajs_x < -L**2) | (trajs_x > L), axis = 1).astype(float)
        first_passage_y = np.argmax((trajs_y < -L**2) | (trajs_y > L), axis = 1).astype(float)

        # Needed transformation to correctly find the minimum considering the presence of zeros
        first_passage_x[first_passage_x == 0] = np.nan
        first_passage_y[first_passage_y == 0] = np.nan    
        first_passage = np.nanmin(np.vstack((first_passage_x, first_passage_y)), axis = 0)
        first_passage[np.isnan(first_passage)] = 0

        # Enlarging the time of those who did not hit the boundaries
        n_loop = 0
        non_passed = np.argwhere(first_passage == 0).flatten()
        last_non_passed = (trajs_x[non_passed, -1], trajs_x[non_passed, -1])    
        while len(non_passed) > 0 and n_loop < max_loop:


            # print('inside')
            trajs_upd_x = rw_generator(len(non_passed),T) + last_non_passed[0][..., np.newaxis]
            trajs_upd_y = rw_generator(len(non_passed),T) + last_non_passed[1][..., np.newaxis]


            # Finding the FPT of the new trajectories
            first_upd_x = np.argmax((trajs_upd_x < -L**2) | (trajs_upd_x > L), axis = 1).astype(float)
            first_upd_y = np.argmax((trajs_upd_y < -L**2) | (trajs_upd_y > L), axis = 1).astype(float)

            # Needed transformation to correctly find the minimum considering the presence of zeros
            first_upd_x[first_upd_x == 0] = np.nan
            first_upd_y[first_upd_y == 0] = np.nan    
            first_upd = np.nanmin(np.vstack((first_upd_x, first_upd_y)), axis = 0)
            first_upd[np.isnan(first_upd)] = 0

            # Adding these to the main FPT array, considering that loop number
            first_passage[non_passed] = (first_upd + (n_loop+1)*T)*first_upd.astype(bool)

            # Checking the ones that still did not pass
            non_passed = np.argwhere(first_passage == 0).flatten()
            # updating the last element of the non passed trajectories
            upd_non_passed = np.argwhere(first_upd == 0).flatten()
            if len(non_passed) != len(upd_non_passed): print('ERROR')
            last_non_passed = (trajs_upd_x[upd_non_passed, -1], trajs_upd_y[upd_non_passed, -1])

            n_loop += 1        

        # Calculating mean considering that some may not have passed              
        first_passage = first_passage[first_passage != 0].mean() 
        if len(non_passed) > 0: print(round(len(non_passed)/len(non_passed),2))
        # Adding this MFPT for current L
        mfpt.append(first_passage)
        
    return mfpt
    

# %% ../nbs/diffusion_walks.ipynb 140
from typing import Callable

def mfpt_informed_rw_2D(N:int, # Number of trajectories
                        T:int, # Lengths of trajectories
                        x0:list, # Starting point of walk (in 2d)
                        Ls:list, # Boundary position
                        traj_generator:Callable,  # Function generating the walk (must start in x0 = zero)
                        max_loop = 5,  # Max number of while loop if some walks do not reach the boundary
                        **args_generator # Arguments of the trajectory generator
                       ): # MFPT vs. L
    ''' Calculates MFPT to boundaries at 0 and L starting in x0 in 2D'''



    # Debug
    # N = 5; T = 50; x0 = [3,3]; Ls = [99]; max_loop = 40


    mfpt = []
    for L in tqdm_term(Ls):   
        
        
        trajs_x, trajs_y = traj_generator(N, T, time_sampler = time_sampler, x0 = x0, L = L, informed = True)        
        trajs_x += x0[0]
        trajs_y += x0[1]

        first_passage_x = np.argmax((trajs_x < 0) | (trajs_x > L), axis = 1).astype(float)
        first_passage_y = np.argmax((trajs_y < 0) | (trajs_y > L), axis = 1).astype(float)

        # Needed transformation to correctly find the minimum considering the presence of zeros
        first_passage_x[first_passage_x == 0] = np.nan
        first_passage_y[first_passage_y == 0] = np.nan    
        first_passage = np.nanmin(np.vstack((first_passage_x, first_passage_y)), axis = 0)
        first_passage[np.isnan(first_passage)] = 0

        # Enlarging the time of those who did not hit the boundaries
        n_loop = 0
        non_passed = np.argwhere(first_passage == 0).flatten()
        last_non_passed = (trajs_x[non_passed, -1], trajs_x[non_passed, -1])    
        while len(non_passed) > 0 and n_loop < max_loop:


            # print('inside')
            trajs_upd_x = rw_generator(len(non_passed),T) + last_non_passed[0][..., np.newaxis]
            trajs_upd_y = rw_generator(len(non_passed),T) + last_non_passed[1][..., np.newaxis]


            # Finding the FPT of the new trajectories
            first_upd_x = np.argmax((trajs_upd_x < 0) | (trajs_upd_x > L), axis = 1).astype(float)
            first_upd_y = np.argmax((trajs_upd_y < 0) | (trajs_upd_y > L), axis = 1).astype(float)

            # Needed transformation to correctly find the minimum considering the presence of zeros
            first_upd_x[first_upd_x == 0] = np.nan
            first_upd_y[first_upd_y == 0] = np.nan    
            first_upd = np.nanmin(np.vstack((first_upd_x, first_upd_y)), axis = 0)
            first_upd[np.isnan(first_upd)] = 0

            # Adding these to the main FPT array, considering that loop number
            first_passage[non_passed] = (first_upd + (n_loop+1)*T)*first_upd.astype(bool)

            # Checking the ones that still did not pass
            non_passed = np.argwhere(first_passage == 0).flatten()
            # updating the last element of the non passed trajectories
            upd_non_passed = np.argwhere(first_upd == 0).flatten()
            if len(non_passed) != len(upd_non_passed): print('ERROR')
            last_non_passed = (trajs_upd_x[upd_non_passed, -1], trajs_upd_y[upd_non_passed, -1])

            n_loop += 1        

        # Calculating mean considering that some may not have passed              
        first_passage = first_passage[first_passage != 0].mean() 
        # Adding this MFPT for current L
        mfpt.append(first_passage)
        
    return mfpt
    
