# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/LW_walker.ipynb (unless otherwise specified).

__all__ = ['lw_step', 'lw_trajs', 'LW_search']

# Cell
import numpy as np
from tqdm.notebook import tqdm
from tqdm import tqdm as tqdmC
from joblib import Parallel, delayed
import matplotlib.pyplot as plt

from .environment import target_env
from en

# Cell
def lw_step(alpha, steps = 1):
    return (1 - np.random.rand(steps))**(-1/alpha)

def lw_trajs(N = 1, T = 100, alpha = 1, L = None, BC = 'reflectant'):

    pos = np.zeros((N, T, 2))

    if L is None:

        angles = np.random.uniform(low = 0, high = 2*np.pi, size = (N, T))
        steps = (1 - np.random.rand(N, T))**(-1/alpha)
        pos[:, :, 0], pos[:, :, 1] = [steps*np.cos(angles), steps*np.sin(angles)]

        return np.cumsum(pos, axis = 1)

    else:

        pos = np.zeros((N, T, 2))
        pos[:, 0, :] = np.random.rand(N, 2)*L

        for t in tqdm(range(1, T)):

            angles = np.random.uniform(low = 0, high = 2*np.pi, size = N)
            steps = (1 - np.random.rand(N))**(-1/alpha)
            pos[:, t, 0] = pos[:, t-1, 0] + steps*np.cos(angles)
            pos[:, t, 1] = pos[:, t-1, 1] + steps*np.sin(angles)


        if BC == 'reflectant':
            while np.max(pos[:, t, :])>L or np.min(pos[: ,t, :])< 0:
                pos[pos > L] = pos[pos > L] - 2*(pos[pos > L] - L)
                pos[pos < 0] = - pos[pos < 0]


        elif BC == 'periodic':
            while np.max(pos[:, t, :])>L or np.min(pos[: ,t, :])< 0:
                pos[pos > L] = pos[pos > L] - L
                pos[pos < 0] = L + pos[pos < 0]



        return pos




# Cell
def LW_search(Nt = 100, at = 1, lc = 1,
              rho = 1e-3,
              L= 1000,
              N = 1000, T = 1000,
              alpha = 0.5,
              BC = 'periodic'):

    diag = np.sqrt(2*L**2)

    target_positions = np.random.rand(Nt, 2)*L

    pos = np.zeros((N, T, 2))
    pos[:, 0, :] = np.random.rand(N, 2)*L

    encounter = np.zeros((N, T)).astype(bool)


    counter_target = 0
    for t in tqdmC(range(1, T)):

        angles = np.random.uniform(low = 0, high = 2*np.pi, size = N)
        steps = (1 - np.random.rand(N))**(-1/alpha)

        steps[steps > diag] = diag
        pos[:, t, 0] = pos[:, t-1, 0] + steps*np.cos(angles)
        pos[:, t, 1] = pos[:, t-1, 1] + steps*np.sin(angles)


        masked = np.array([False]*N)
        for idxT, pT in enumerate(target_positions):

            mask = isBetween_ab_Vec(pos[:, t, :], pos[:, t-1, :], pT, epsilon = at)

            masked += np.array(mask)

            pos[mask == True, t, :] = pT

        encounter[:, t] = masked
        sum_m = np.sum(masked)

        '''Here there is a mistake, because the we are summing the lc to the current
        position of the target, and not to the center of the target... This means that
        the walker can end up at a distance larger than lc!'''
        if sum_m > 0:
            angle = np.random.uniform(low = 0, high = 2*np.pi, size = sum_m)
            pos[masked == True, t, 0] += lc*np.cos(angle)
            pos[masked == True, t, 1] += lc*np.sin(angle)

        if BC == 'reflectant':
            while np.max(pos[:, t, :])>L or np.min(pos[: ,t, :])< 0:
                pos[pos > L] = pos[pos > L] - 2*(pos[pos > L] - L)
                pos[pos < 0] = - pos[pos < 0]
        if BC == 'periodic':
            while np.max(pos[:, t, :])>L or np.min(pos[: ,t, :])< 0:
                pos[pos > L] = pos[pos > L] - L
                pos[pos < 0] = L + pos[pos < 0]

    return encounter
