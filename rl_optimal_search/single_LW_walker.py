# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/single_LW_walker.ipynb (unless otherwise specified).

__all__ = ['lw_step', 'lw_trajs', 'get_distance', 'isBetween', 'isBetween_ab_Vec', 'isBetween_c_Vec', 'LW_search']

# Cell
import numpy as np
from tqdm.notebook import tqdm
from tqdm import tqdm as tqdmC
from joblib import Parallel, delayed

# Cell
def lw_step(alpha, steps = 1):
    return (1 - np.random.rand(steps))**(-1/alpha)

def lw_trajs(N = 1, T = 100, alpha = 1, L = None, BC = 'reflectant'):

    pos = np.zeros((N, T, 2))

    if L is None:

        angles = np.random.uniform(low = 0, high = 2*np.pi, size = (N, T))
        steps = (1 - np.random.rand(N, T))**(-1/alpha)
        pos[:, :, 0], pos[:, :, 1] = [steps*np.cos(angles), steps*np.sin(angles)]

        return np.cumsum(pos, axis = 1)

    else:

        pos = np.zeros((N, T, 2))
        pos[:, 0, :] = np.random.rand(N, 2)*L

        for t in tqdm(range(1, T)):

            angles = np.random.uniform(low = 0, high = 2*np.pi, size = N)
            steps = (1 - np.random.rand(N))**(-1/alpha)
            pos[:, t, 0] = pos[:, t-1, 0] + steps*np.cos(angles)
            pos[:, t, 1] = pos[:, t-1, 1] + steps*np.sin(angles)


        if BC == 'reflectant':
            while np.max(pos[:, t, :])>L or np.min(pos[: ,t, :])< 0:
                pos[pos > L] = pos[pos > L] - 2*(pos[pos > L] - L)
                pos[pos < 0] = - pos[pos < 0]


        if BC == 'periodic':
            while np.max(pos[:, t, :])>L or np.min(pos[: ,t, :])< 0:
                pos[pos > L] = pos[pos > L] - L
                pos[pos < 0] = L + pos[pos < 0]



        return pos




# Cell
from scipy.optimize import curve_fit
from scipy.special import factorial
from scipy.stats import poisson


def get_distance(x):
    M = np.reshape(np.repeat(x[ :, :], x.shape[0], axis = 0), (x.shape[0], x.shape[0], 2))
    Mtrans = M.transpose(1,0,2)
    distance = np.sqrt(np.square(M[:,:, 0]-Mtrans[:,:, 0])
                     + np.square(M[:,:, 1]-Mtrans[:,:, 1]))
    return distance

def isBetween(a, b, c, epsilon = 0):
    crossproduct = (c[1] - a[1]) * (b[0] - a[0]) - (c[0] - a[0]) * (b[1] - a[1])

    # compare versus epsilon for floating point values, or != 0 if using integers
    if abs(crossproduct) > epsilon:
        return False

    dotproduct = (c[0] - a[0]) * (b[0] - a[0]) + (c[1] - a[1])*(b[1] - a[1])
    if dotproduct < 0:
        return False

    squaredlengthba = (b[0] - a[0])*(b[0] - a[0]) + (b[1] - a[1])*(b[1] - a[1])
    if dotproduct > squaredlengthba:
        return False

    return True

def isBetween_ab_Vec(a, b, c, epsilon = 0):
    mask = np.array([True]*a.shape[0])

    crossproduct = (c[1] - a[:,1]) * (b[:,0] - a[:,0]) - (c[0] - a[:, 0]) * (b[:, 1] - a[:, 1])
    mask[np.argwhere(abs(crossproduct) > epsilon)] = False

    dotproduct = (c[0] - a[:, 0]) * (b[:, 0] - a[:, 0]) + (c[1] - a[:, 1])*(b[:, 1] - a[:, 1])
    mask[np.argwhere(dotproduct < 0)] = False

    squaredlengthba = (b[:, 0] - a[:, 0])*(b[:, 0] - a[:, 0]) + (b[:, 1] - a[:, 1])*(b[:, 1] - a[:, 1])
    mask[np.argwhere(dotproduct > squaredlengthba)] = False

    return mask

def isBetween_c_Vec(a, b, c, epsilon = 0):
    mask = np.array([True]*c.shape[0])

    crossproduct = (c[:,1] - a[1]) * (b[0] - a[0]) - (c[:,0] - a[0]) * (b[1] - a[1])
    mask[np.argwhere(abs(crossproduct) > epsilon)] = False

    dotproduct = (c[:, 0] - a[0]) * (b[0] - a[0]) + (c[:, 1] - a[1])*(b[1] - a[1])
    mask[np.argwhere(dotproduct < 0)] = False

    squaredlengthba = (b[0] - a[0])*(b[0] - a[0]) + (b[1] - a[1])*(b[1] - a[1])
    mask[np.argwhere(dotproduct > squaredlengthba)] = False

    return mask

# Cell
def LW_search(Nt = 100, at = 1, lc = 1,
              rho = 1e-3,
              L= 1000,
              N = 1000, T = 1000,
              alpha = 0.5,
              BC = 'periodic'):

    diag = np.sqrt(2*L**2)

    target_positions = np.random.rand(Nt, 2)*L

    pos = np.zeros((N, T, 2))
    pos[:, 0, :] = np.random.rand(N, 2)*L

    encounter = np.zeros((N, T)).astype(bool)


    counter_target = 0
    for t in tqdmC(range(1, T)):

        angles = np.random.uniform(low = 0, high = 2*np.pi, size = N)
        steps = (1 - np.random.rand(N))**(-1/alpha)

        steps[steps > diag] = diag
        pos[:, t, 0] = pos[:, t-1, 0] + steps*np.cos(angles)
        pos[:, t, 1] = pos[:, t-1, 1] + steps*np.sin(angles)


        masked = np.array([False]*N)
        for idxT, pT in enumerate(target_positions):

            mask = isBetween_ab_Vec(pos[:, t, :], pos[:, t-1, :], pT, epsilon = at)

            masked += np.array(mask)

            pos[mask == True, t, :] = pT

        encounter[:, t] = masked
        sum_m = np.sum(masked)

        if sum_m > 0:
            angle = np.random.uniform(low = 0, high = 2*np.pi, size = sum_m)
            pos[masked == True, t, 0] += lc*np.cos(angle)
            pos[masked == True, t, 1] += lc*np.sin(angle)

        if BC == 'reflectant':
            while np.max(pos[:, t, :])>L or np.min(pos[: ,t, :])< 0:
                pos[pos > L] = pos[pos > L] - 2*(pos[pos > L] - L)
                pos[pos < 0] = - pos[pos < 0]
        if BC == 'periodic':
            while np.max(pos[:, t, :])>L or np.min(pos[: ,t, :])< 0:
                pos[pos > L] = pos[pos > L] - L
                pos[pos < 0] = L + pos[pos < 0]

    return encounter
